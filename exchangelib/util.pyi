import io
import logging
import lxml.etree
import xml.sax.handler
from .errors import ErrorInternalServerTransientError as ErrorInternalServerTransientError, ErrorTimeoutExpired as ErrorTimeoutExpired, RelativeRedirect as RelativeRedirect, TransportError as TransportError
from _typeshed import Incomplete
from collections.abc import Generator
from defusedxml.expatreader import DefusedExpatParser

log: Incomplete
xml_log: Incomplete

def require_account(f): ...
def require_id(f): ...

class ParseError(lxml.etree.ParseError): ...

class ElementNotFound(Exception):
    data: Incomplete
    def __init__(self, msg, data) -> None: ...

SOAPNS: str
MNS: str
TNS: str
ENS: str
ANS: str
INS: str
WSA: str
AUTODISCOVER_BASE_NS: str
AUTODISCOVER_REQUEST_NS: str
AUTODISCOVER_RESPONSE_NS: str
ns_translation: Incomplete

def is_iterable(value, generators_allowed: bool = False): ...
def chunkify(iterable, chunksize) -> Generator[Incomplete]: ...
def peek(iterable): ...
def xml_to_str(tree, encoding: Incomplete | None = None, xml_declaration: bool = False): ...
def get_xml_attr(tree, name): ...
def get_xml_attrs(tree, name): ...
def value_to_xml_text(value): ...
def xml_text_to_value(value, value_type): ...
def set_xml_value(elem, value, version: Incomplete | None = None): ...
def safe_xml_value(value, replacement: str = '?'): ...
def sanitize_xml(data, replacement: bytes = b'?'): ...
def create_element(name, attrs: Incomplete | None = None, nsmap: Incomplete | None = None): ...
def add_xml_child(tree, name, value) -> None: ...

class StreamingContentHandler(xml.sax.handler.ContentHandler):
    def __init__(self, parser, ns, element_name) -> None: ...
    def startElementNS(self, name, qname, attrs) -> None: ...
    def endElementNS(self, name, qname) -> None: ...
    def characters(self, content) -> None: ...

def prepare_input_source(source): ...
def safe_b64decode(data): ...

class StreamingBase64Parser(DefusedExpatParser):
    buffer: Incomplete
    element_found: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...
    def parse(self, r) -> Generator[Incomplete, Incomplete]: ...
    def feed(self, data, isFinal: int = 0): ...

class BytesGeneratorIO(io.RawIOBase):
    def __init__(self, bytes_generator) -> None: ...
    def readable(self): ...
    def tell(self): ...
    def read(self, size: int = -1): ...
    def close(self) -> None: ...

class DocumentYielder:
    def __init__(self, content_iterator, document_tag: str = 'Envelope') -> None: ...
    def __iter__(self): ...

def to_xml(bytes_content): ...
def is_xml(text): ...

class PrettyXmlHandler(logging.StreamHandler):
    @staticmethod
    def parse_bytes(xml_bytes): ...
    def prettify_xml(self, xml_bytes): ...
    @staticmethod
    def highlight_xml(xml_str): ...
    def emit(self, record): ...
    def is_tty(self): ...

class AnonymizingXmlHandler(PrettyXmlHandler):
    PRIVATE_TAGS: Incomplete
    forbidden_strings: Incomplete
    def __init__(self, forbidden_strings, *args, **kwargs) -> None: ...
    def parse_bytes(self, xml_bytes): ...

class DummyRequest:
    headers: Incomplete
    def __init__(self, headers: Incomplete | None = None) -> None: ...

class DummyResponse:
    status_code: Incomplete
    url: Incomplete
    headers: Incomplete
    content: Incomplete
    text: Incomplete
    request: Incomplete
    reason: str
    history: Incomplete
    def __init__(self, url: Incomplete | None = None, headers: Incomplete | None = None, request_headers: Incomplete | None = None, content: bytes = b'', status_code: int = 503, streaming: bool = False, history: Incomplete | None = None) -> None: ...
    def iter_content(self): ...
    def close(self) -> None: ...

def get_domain(email): ...
def split_url(url): ...
def get_redirect_url(response, allow_relative: bool = True, require_relative: bool = False): ...

CONNECTION_ERRORS: Incomplete
TLS_ERRORS: Incomplete

def post_ratelimited(protocol, session, url, headers, data, stream: bool = False, timeout: Incomplete | None = None): ...
